Index: ../.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*.xlsx\n/*.pdf\n/mat/\n/OpenOrd/\n/dataset/\n/output/\n.idea/\n/emb\n.DS_Store\n__pycache__/\n/*.pyc\n/venv\n/*.sh
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../.gitignore b/../.gitignore
--- a/../.gitignore	(revision f439698caf8deac89815610cdf58f7b3b409d2c3)
+++ b/../.gitignore	(date 1608361646208)
@@ -1,13 +1,37 @@
-/*.xlsx
-/*.pdf
-/mat/
-/OpenOrd/
-/dataset/
-/output/
-.idea/
-/emb
-.DS_Store
-__pycache__/
-/*.pyc
-/venv
-/*.sh
\ No newline at end of file
+qrc_*cxx
+*.orig
+*.pyc
+*.diff
+diff
+*.save
+save
+*.old
+*.gmo
+*.qm
+core
+core.*
+*.bak
+*~
+*build*
+*.moc.*
+*.moc
+ui_*
+CMakeCache.txt
+tags
+.*.swp
+activity.png
+*.out
+*.php*
+*.log
+*.orig
+*.rej
+log
+patch
+*.patch
+a
+a.*
+lapack/testing
+lapack/reference
+.*project
+.settings
+Makefile
Index: algo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Jeremy Shiqi Zhang on 2020/8/30.\n//\n\n#ifndef INTERACT_FORA_ALGO_H\n#define INTERACT_FORA_ALGO_H\n\n#include \"lib.h\"\n#include <boost/serialization/serialization.hpp>\n#include <boost/archive/text_oarchive.hpp>\n#include <boost/archive/binary_oarchive.hpp>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/archive/binary_iarchive.hpp>\n#include <boost/serialization/vector.hpp>\n#include <boost/serialization/map.hpp>\n#include <boost/serialization/utility.hpp>\nusing namespace boost;\nusing namespace std;\n\n\nstring hiename,mapname,rootname,storepath,rwpath;\n//vector<Bwdidx> offline_idx;\n//vector<vector<pair<int,double>>> ppr_idx;\nvector<unsigned long long> rw_idx_info_offset;\nvector<unsigned long> rw_idx_info_size;\nvector<string> root;\nunordered_map<string,vector<int>> super2leaf;\nunordered_map<string,vector<int>> super2super;\nvector<int> rw_idx;\nvector<Fwdidx> fwd_idx;\nvector<Fwdidx> virtual_fwd_idx;\n//vector<Fwdcache> fwd_stack;\nvector<vector<int>> leaf2id_stack;\nint fwd_stack_top;\n//Fwdcache* fwdcache;\nvector<int>* leaf2id;\n// current rsum for each leaf source node\n//vector<double> rsums;\n// store superPPRDeg between supernodes in current level\nvector<double> PPRDeg;\nGraph graph;\nvector<vector<int>> queues;\nvector<vector<int>> rwfreq;\n//unsigned long long num_hit_idx;\n//unsigned long long nnz;\n//unsigned long long num_total_rw;\n//unsigned long long num_rw_level;\nstring visual_mode; // decide which mode to use: interactive or full?\nint thread_num;\ndouble timeElasped;\n\ndouble timeBy(double start){\n    return (clock()-start)/CLOCKS_PER_SEC;\n}\n\n//inline static double drand(){\n//    return rand()*1.0f/RAND_MAX;\n//    // return sfmt_genrand_real1(&sfmtSeed);\n//}\n//\n//inline static unsigned long lrand() {\n//    return rand();\n//    // return sfmt_genrand_uint32(&sfmtSeed);\n//}\n\ninline static double drand(unsigned int &seed){\n    return rand_r(&seed)*1.0f/RAND_MAX;\n    // return sfmt_genrand_real1(&sfmtSeed);\n}\n\ninline static unsigned long lrand(unsigned int &seed) {\n    return rand_r(&seed);\n    // return sfmt_genrand_uint32(&sfmtSeed);\n}\n\ninline int random_walk(int start, unsigned int &seed){\n    int cur = start;\n    unsigned long k;\n    if(graph.g[start].empty()){\n        return start;\n    }\n    while (true) {\n        if (drand(seed) < graph.alpha) {\n            return cur;\n        }\n        if (!graph.g[cur].empty()){\n            k = lrand(seed)%graph.g[cur].size();\n            cur = graph.g[cur][k];\n        }\n        else{\n            cur = start;\n        }\n    }\n}\n\n\nint parseLine(char* line){\n    // This assumes that a digit will be found and the line ends in \" Kb\".\n    int i = strlen(line);\n    const char* p = line;\n    while (*p <'0' || *p > '9') p++;\n    line[i-3] = '\\0';\n    i = atoi(p);\n    return i;\n}\n\nint extract_supernode(string supernode, int &component, int &level){\n    size_t pos = 0;\n    string token;\n    string delimiter = \"_\";\n    int i=1;\n    int sid;\n    while ((pos = supernode.find(delimiter)) != std::string::npos) {\n        token = supernode.substr(1, pos-1);\n//        std::cout << token << std::endl;\n        if(i==1)\n            component = stoi(token);\n        else if(i==2)\n            level = stoi(token);\n        supernode.erase(0, pos + delimiter.length());\n        i++;\n    }\n    assert(i==3);\n//    std::cout << supernode << std::endl;\n    sid = stoi(supernode);\n    return sid;\n}\n\nvoid parse_children(const string &supernode, int &level,vector<string>&partition){\n    int component;\n    extract_supernode(supernode,component,level);\n    if (level<=1)\n        return;\n    vector<int> &child = super2super[supernode];\n    partition.resize(child.size());\n    for (int i = 0; i < child.size(); ++i) {\n        partition[i] = \"c\"+to_string(component)+\"_l\"+to_string(level-1)+\"_\"+to_string(child[i]);\n    }\n}\n\ndouble getMemory(){ //Note: this value is in MB!\n    FILE* file = fopen(\"/proc/self/status\", \"r\");\n    int result = -1;\n    char line[128];\n\n    while (fgets(line, 128, file) != NULL){\n        if (strncmp(line, \"VmRSS:\", 6) == 0){\n            result = parseLine(line);\n            break;\n        }\n    }\n    fclose(file);\n    return result/1024.0;\n}\nvoid generate_random_path(vector<string> &path, int maxlevel){\n    assert(maxlevel>1);\n    int level = maxlevel;\n    string item = \"c0_l\"+to_string(maxlevel)+\"_0\";\n    cerr<<item<<\" \";\n    path.push_back(item);\n    while (level>1){\n        int size = super2super[item].size();\n        level--;\n        item = \"c0_l\"+to_string(level)+\"_\"+to_string(super2super[item][rand()%size]);\n        cerr<<item<<\" \";\n        path.push_back(item);\n    }\n    cerr<<endl;\n}\nint load_multilevel(){\n    std::ifstream mapifs,hierifs,rotifs;\n    mapifs.open(mapname);\n    hierifs.open(hiename);\n    rotifs.open(rootname);\n    string name;\n    int max_level=0;\n    int size;\n    int node;\n    int _;\n    assert(mapifs.is_open() && hierifs.is_open() && rotifs.is_open());\n    while(!mapifs.eof())\n    {\n        mapifs >> name >> size;\n        vector<int> leafs(size);\n        for (int i = 0; i < size; ++i) {\n            mapifs >> node;\n            leafs[i]=node;\n        }\n        super2leaf.insert({name,leafs});\n    }\n    while(!rotifs.eof())\n    {\n        rotifs >> name;\n        root.push_back(name);\n    }\n    while(!hierifs.eof())\n    {\n        hierifs >> name >> size;\n        vector<int> leafs(size);\n        for (int i = 0; i < size; ++i) {\n            hierifs >> node;\n            leafs[i]=node;\n        }\n        int level;\n        extract_supernode(name,_,level);\n        if (level>max_level)\n            max_level=level;\n        super2super.insert({name,leafs});\n    }\n    mapifs.close();\n    hierifs.close();\n    if (verbose)\n        cout<<\"load multilevel success: super2leaf \"<<super2leaf.size()<<\" super2super \"<<super2super.size()<<endl;\n    return max_level;\n}\n\ninline void serialize_idx(string &path){\n    string file_name = path+\".idx\";\n    std::ofstream ofs(file_name);\n    boost::archive::binary_oarchive oa(ofs);\n    oa << rw_idx;\n\n    string info_name = path+\".info.offset\";\n    std::ofstream info_ofs(info_name);\n    boost::archive::binary_oarchive info_oa(info_ofs);\n    info_oa << rw_idx_info_offset;\n\n    string size_name = path+\".info.size\";\n    std::ofstream size_ofs(size_name);\n    boost::archive::binary_oarchive size_oa(size_ofs);\n    size_oa << rw_idx_info_size;\n}\n\nvoid build(){\n    double epsilon =1-exp(-2*graph.epR);\n    double Delta = 25*graph.dbar; // Delta = k*dbar k=25\n    // todo: currently, use dbar*delta as deltap and tau = 1 for randwalk index construction\n//    double deltap = graph.dbar*graph.delta;\n    double deltap = graph.dbar/graph.n;\n    double rmax = epsilon*sqrt(deltap*Delta/(2+2*epsilon/3)/2/(double)graph.m/log(1/graph.pfail));\n//    rmax *= graph.rmax_scale;\n    double omega = (2+2*epsilon/3)*log(1/graph.pfail)/deltap/epsilon/epsilon;\n    unsigned int seed = rand();\n\n    // rw_idx = RwIdx( graph.n, vector<int>() );\n    rw_idx_info_offset.resize(graph.n);\n    rw_idx_info_size.resize(graph.n);\n    unsigned long long rw_max_size = 2*graph.m*rmax*omega;\n    rw_idx.reserve(rw_max_size);\n    double start = omp_get_wtime();\n    {\n        unsigned long num_rw;\n        for(int source=0; source<graph.n; source++){ //from each node, do rand-walks\n            num_rw = ceil(graph.g[source].size()*rmax*omega);\n            rw_idx_info_offset[source] = rw_idx.size();\n            rw_idx_info_size[source] = num_rw;\n            for(unsigned long i=0; i<num_rw; i++){ //for each node, do some rand-walks\n                int destination = random_walk(source,seed);\n                // rw_idx[source].push_back(destination);\n                rw_idx.push_back(destination);\n            }\n        }\n    }\n\n//    for (auto each:rw_idx_info)\n//        cout << each.first<<\" \"<< each.second<<endl;\n\n    cout <<\"rwindextime:\"<<omp_get_wtime()-start<<endl;\n    {\n        serialize_idx(rwpath);\n    }\n#ifdef linux\n    cerr << \"Memory usage (MB):\" << getMemory()<< endl << endl;\n#endif\n}\n\nbool exists_test(const std::string &name) {\n    ifstream f(name.c_str());\n    if (f.good()) {\n        f.close();\n        return true;\n    }\n    else {\n        f.close();\n        return false;\n    }\n}\n\nvoid assert_file_exist(string desc, string name) {\n\n    if (!exists_test(name)) {\n        cerr << desc << \" \" << name << \" not find \" << endl;\n        exit(1);\n    }\n}\n\ninline void deserialize_idx(){\n    string file_name = rwpath+\".idx\";\n    assert_file_exist(\"index file\", file_name);\n    std::ifstream ifs(file_name);\n    boost::archive::binary_iarchive ia(ifs);\n    ia >> rw_idx;\n\n    string info_name = rwpath+\".info.offset\";\n    assert_file_exist(\"index file\", file_name);\n    std::ifstream info_ifs(info_name);\n    boost::archive::binary_iarchive info_ia(info_ifs);\n    info_ia >> rw_idx_info_offset;\n\n    string size_name = rwpath+\".info.size\";\n    assert_file_exist(\"index file\", size_name);\n    std::ifstream size_ifs(size_name);\n    boost::archive::binary_iarchive size_ia(size_ifs);\n    size_ia >> rw_idx_info_size;\n\n}\n\nvoid init_container(){\n    fwd_idx.resize(thread_num);\n    virtual_fwd_idx.resize(thread_num);\n    queues.resize(thread_num);\n    rwfreq.resize(thread_num);\n    for (int i = 0; i < thread_num; ++i) {\n        fwd_idx[i].first.initialize(graph.n);\n        fwd_idx[i].second.initialize(graph.n);\n        virtual_fwd_idx[i].first.initialize(graph.n);\n        virtual_fwd_idx[i].second.initialize(graph.n);\n        queues[i].reserve(graph.n);\n        rwfreq[i].resize(graph.n);\n    }\n\n//    rsums.resize(graph.n);\n    // initialize stack info\n//    fwd_stack.resize(graph.max_level);\n    leaf2id_stack.resize(graph.max_level);\n    fwd_stack_top=0;\n}\n\nbool is_checked_rsum(double rsum, int tid){\n    double correct = 0;\n    for(long i=0; i < virtual_fwd_idx[tid].second.occur.m_num; i++){\n        int source = virtual_fwd_idx[tid].second.occur[i];\n        correct+=virtual_fwd_idx[tid].second[source];\n    }\n//    cout << rsum<<\" \"<<correct<<endl;\n    return abs(rsum-correct)<10e-6;\n}\n// given a queue, keep push the residue until no one larger than rmax\n// during the process, update fwd_idx and rsum\nvoid forward_push(vector<int> &q, unsigned long left,\n                  double &rsum, double rmax,int tid) {\n    Fwdidx &fwdidx = fwd_idx[tid];\n    double myeps = rmax;//config.rmax;\n    while (left < (int) q.size()) {\n        int v = q[left];\n        left++;\n        double v_residue = fwdidx.second[v];\n        fwdidx.second[v] = 0;\n        if(!fwdidx.first.exist(v))\n            fwdidx.first.insert( v, v_residue * graph.alpha);\n        else\n            fwdidx.first[v] += v_residue * graph.alpha;\n\n        int out_neighbor = graph.g[v].size();\n        rsum -=v_residue*graph.alpha;\n        assert(out_neighbor > 0);\n\n        double avg_push_residual = ((1.0 - graph.alpha) * v_residue) / out_neighbor;\n        for (int next : graph.g[v]) {\n            // total_push++;\n            double oldep;\n            if( !fwdidx.second.exist(next) ){\n                oldep = 0;\n                fwdidx.second.insert( next,  avg_push_residual);\n            }\n            else{\n                oldep = fwdidx.second[next];\n                fwdidx.second[next] += avg_push_residual;\n            }\n            //if a node's' current residual is small, but next time it got a large residual, it can still be added into forward list\n            //so this is correct\n            if (oldep/graph.g[next].size() <= myeps && fwdidx.second[next]/graph.g[next].size() > myeps) {\n                q.push_back(next);\n            }\n        }\n    }\n    if(verbose){\n        double correct = 0;\n        for(long i=0; i < fwdidx.second.occur.m_num; i++){\n            int source = fwdidx.second.occur[i];\n            correct += fwdidx.second[source];\n        }\n        assert(abs(rsum-correct)<10e-6);\n    }\n}\n\nvoid update_cache_virtual_fwd(int leaf, int tid){\n    Fwdidx &vfwdidx = virtual_fwd_idx[tid];\n    Fwdidx &fwdidx = fwd_idx[tid];\n    if(visual_mode == INTERACT_MODE){\n        int pos = (*leaf2id)[leaf];\n//        Fwdcache & cache = *fwdcache;\n//        cacheBlock &block = cache[pos];\n//        // todo: modify for openmp\n//        block.pdst.resize(fwdidx.first.occur.m_num);\n//        block.p.resize(fwdidx.first.occur.m_num);\n\n        for(long i=0; i < fwdidx.first.occur.m_num; i++){\n            int source = fwdidx.first.occur[i];\n            double reserve = fwdidx.first[source];\n            // insert for reserve_cache\n//            block.pdst[i] = source;\n//            block.p[i] = reserve;\n            if (reserve==0)\n                continue;\n            // update virtual_fwd_idx\n            if( !vfwdidx.first.exist(source) )\n                vfwdidx.first.insert(source, reserve);\n            else\n                vfwdidx.first[source] += reserve;\n//        if (verbose)\n//            cout<<\"virtual_fwd_idx p\"<<source<<\": \"<<virtual_fwd_idx.first[source]<<endl;\n        }\n//        block.rdst.resize(fwdidx.second.occur.m_num);\n//        block.r.resize(fwdidx.second.occur.m_num);\n        for(long i=0; i < fwdidx.second.occur.m_num; i++){\n            int source = fwdidx.second.occur[i];\n            double residual = fwdidx.second[source];\n            // insert for reside_cache\n//            block.rdst[i] = source;\n//            block.r[i] = residual;\n            if (residual==0)\n                continue;\n            // update virtual_fwd_idx\n            if( !vfwdidx.second.exist(source) )\n                vfwdidx.second.insert(source, residual);\n            else\n                vfwdidx.second[source] += residual;\n//        if (verbose)\n//            cout<<\"virtual_fwd_idx r\"<<source<<\": \"<<virtual_fwd_idx.second[source]<<endl;\n        }\n    }\n\n    else{\n        for(long i=0; i < fwdidx.first.occur.m_num; i++){\n            int source = fwdidx.first.occur[i];\n            double reserve = fwdidx.first[source];\n            if (reserve==0)\n                continue;\n            // update virtual_fwd_idx\n            vfwdidx.first.insert(source, reserve);\n        }\n        for(long i=0; i < fwdidx.second.occur.m_num; i++){\n            int source = fwdidx.second.occur[i];\n            double residual = fwdidx.second[source];\n            // insert for reside_cache\n            if (residual==0)\n                continue;\n            // update virtual_fwd_idx\n            vfwdidx.second.insert(source, residual);\n        }\n    }\n}\n\nvoid load_queue_fwd_idx(double init_residual,double rmax,\n                        const cacheBlock &reserCache, vector<int> &q, int tid) {\n    const vector<int> &pdst = reserCache.pdst;\n    const vector<double> &p = reserCache.p;\n    long size = pdst.size();\n    Fwdidx &fwdidx = fwd_idx[tid];\n    for (int i = 0; i <size; ++i) {\n        fwdidx.first.insert(pdst[i], p[i]*init_residual);\n    }\n    const vector<int> &rdst = reserCache.rdst;\n    const vector<double> &r = reserCache.r;\n    double residual;\n    int node;\n    size = rdst.size();\n    for (int i = 0; i <size; ++i) {\n        if(r[i]==0)\n            continue;\n        node = rdst[i];\n        residual = r[i]*init_residual;\n        fwdidx.second.insert(node, residual);\n        if(residual/graph.g[node].size()>rmax)\n            q.push_back(rdst[i]);\n    }\n}\n\n\nvoid forward_local_update_linear(int s, const string &Father, double& rsum, double rmax, int tid){\n    double init_residual;\n    vector<int> *ids;\n    Fwdidx &fwdidx = fwd_idx[tid];\n//    if(fwd_stack_top==0 || visual_mode==FULL_MODE)\n    init_residual = graph.g[s].size();\n//    else{\n//        ids = &leaf2id_stack[fwd_stack_top-1];\n//        init_residual = (double)super2leaf[Father].size();\n//    }\n\n    // load reserve and residue info from stack\n    // initialize queue and fwd_idx by rescaling the cache results\n    // set rmax for leaf forward push\n    double myeps = rmax;\n    // set rmax for leaf forward push\n    double r = init_residual;\n    // if initial residue is small enough, just skip\n    if(r/graph.g[s].size() < myeps){\n        rsum=r;\n        return;\n    }\n    vector<int> &q = queues[tid];\n    q.push_back(-1);\n    unsigned long left = 1;\n    // make sure fwd_idx is clean before usage\n    assert(fwdidx.second.occur.m_num==0);\n    assert(fwdidx.first.occur.m_num==0);\n\n//    if (fwd_stack_top==0 || visual_mode==FULL_MODE){\n    // initial queue\n    q.push_back(s);\n    // initial rsum\n//    rsums[s] = r;\n    // initial fwd_idx\n    fwdidx.second.insert(s, r);\n//    } else{\n//        // load reserve and residue cache from current leaf\n//        // map leaf id to vector id\n//        load_queue_fwd_idx(init_residual,myeps, fwd_stack[fwd_stack_top-1][(*ids)[s]], q,tid);\n//        // scale the rsum value for current level\n//        rsums[s] *= init_residual;\n//    }\n\n    // start forward push\n    forward_push(q, left, r, myeps,tid);\n    // collect the rsum from each leaf source\n    rsum=r;\n    // store fwd_idx info into cache and virtual_fwd_idx\n//    update_cache_virtual_fwd(s);\n    // check rsum is correct here\n//    if(verbose)\n//        assert(is_checked_rsum(rsum));\n    // clean fwd_idx\n    q.clear();\n    q.reserve(graph.n);\n//    fwd_idx.first.clean();\n//    fwd_idx.second.clean();\n}\n\nvoid forward_local_update_virtual(const string &S, const string &Father,\n                                  double& rsum, double rmax, int dsum, int tid){\n    double init_residual;\n    vector<int> *ids;\n//    if(fwd_stack_top==0)\n    init_residual = dsum/(double)super2leaf[S].size();\n//    else{\n//        ids = &leaf2id_stack[fwd_stack_top-1];\n//        init_residual = (double)super2leaf[Father].size()/(double)super2leaf[S].size();\n//    }\n    // load reserve and residue info from stack\n    for(int leaf:super2leaf[S]){\n        // initialize queue and fwd_idx by rescaling the cache results\n        double frac = graph.g[leaf].size()/(double)dsum;\n        double myeps = frac*rmax; // d(leaf)/dsum fraction of rmax;\n//        /graph.g[next].size() > myeps\n        // set rmax for leaf forward push\n        double r = frac*init_residual;\n        // if initial residue is small enough, just skip\n        if(r/graph.g[leaf].size() < myeps){\n            rsum+=r;\n            continue;\n        }\n        vector<int> &q = queues[tid];\n        q.push_back(-1);\n        unsigned long left = 1;\n        // make sure fwd_idx is clean before usage\n        pair<iMap<double>, iMap<double>> &fwdidx = fwd_idx[tid];\n        assert(fwdidx.second.occur.m_num == 0);\n        assert(fwdidx.first.occur.m_num == 0);\n        // set rmax for leaf forward push\n\n//        if(fwd_stack_top==0){\n        // initial queue\n        q.push_back(leaf);\n        // initial rsum\n        // rsums[leaf] = r;\n        // initial fwd_idx\n        fwdidx.second.insert(leaf, r);\n//        }\n//        else{\n//            // load queue and fwd_idx from cache\n//            // map leaf id to vector id\n//            load_queue_fwd_idx(init_residual, myeps,fwd_stack[fwd_stack_top-1][(*ids)[leaf]],q,tid);\n//            // refresh the rsum value by scaling\n//            rsums[leaf] *= init_residual;\n//        }\n        // start forward push\n        forward_push(q, left, r, myeps,tid);\n        // collect the rsum from each leaf source\n        rsum+=r;\n        // store fwd_idx info into cache and virtual_fwd_idx\n        update_cache_virtual_fwd(leaf,tid);\n        // clean fwd_idx\n        q.clear();\n        q.reserve(graph.n);\n        fwdidx.first.clean();\n        fwdidx.second.clean();\n    }\n    // check rsum is correct here\n//    if(verbose)\n//        assert(is_checked_rsum(rsum,tid));\n\n}\n\nvoid compute_ppr_with_fwdidx(int S, const string &Father,unsigned long long &num_random_walk,\n                             double omega, double check_rsum, int tid,\n                             vector<int> &spprs,vector<int> &spprt,vector<double> &spprv,\n                             unsigned int &seed){\n    // INFO(\"rsum is:\", check_rsum);\n    Fwdidx &fwdidx = fwd_idx[tid];\n    if(check_rsum == 0.0 or omega * check_rsum < 1){\n        if(visual_mode==INTERACT_MODE){\n            for(int T:super2leaf[Father]){\n                double pprdeg=0;\n                if(fwdidx.first.exist(T) )\n                    pprdeg+=fwdidx.first[T];\n                if (pprdeg>0){\n                    spprs.push_back(S);\n                    spprt.push_back(T);\n                    spprv.push_back(pprdeg);\n                }\n            }\n        }\n        else{//FULL_MODE here\n            for(long i=0; i < fwdidx.first.occur.m_num; i++){\n                int T = fwdidx.first.occur[i];\n                double reserve = fwdidx.first[T];\n                if (reserve==0)\n                    continue;\n                spprs.push_back(S);\n                spprt.push_back(T);\n                spprv.push_back(reserve);\n            }\n        }\n\n        return;\n    }\n\n// todo: modify here\n    vector<int> &freq=rwfreq[tid];\n    // INFO(num_random_walk);\n\n    //rand walk online\n    if (graph.isOnline){\n        for(long i=0; i < fwdidx.second.occur.m_num; i++){\n            int source = fwdidx.second.occur[i];\n            double residual = fwdidx.second[source];\n\n//            if (residual<threshold)\n            if (residual==0)\n                continue;\n//            nnz++;\n            unsigned long num_s_rw = ceil(residual*omega);\n//            num_total_rw += num_s_rw;\n//            num_rw_level += num_s_rw;\n            num_random_walk+=num_s_rw;\n\n\n            for(unsigned long j=0; j<num_s_rw; j++){\n                int des = random_walk(source, seed);\n                freq[des] += 1;\n            }\n        }\n    }else{\n        fwdidx.second.occur.Sort();\n        for(long i=0; i < fwdidx.second.occur.m_num; i++){\n            int source = fwdidx.second.occur[i];\n            double residual = fwdidx.second[source];\n\n//            if(residual<threshold)\n            if (residual==0)\n                continue;\n//            nnz++;\n            unsigned long num_s_rw = ceil(residual*omega);\n//            num_total_rw += num_s_rw;\n//            num_rw_level += num_s_rw;\n            num_random_walk += num_s_rw;\n\n            //for each source node, get rand walk destinations from previously generated idx or online rand walks\n            if(num_s_rw > rw_idx_info_size[source]){ //if we need more destinations than that in idx, rand walk online\n                for(unsigned long k=0; k<rw_idx_info_size[source]; k++){\n                    int des = rw_idx[rw_idx_info_offset[source] + k];\n                    freq[des] += 1;\n                }\n//                num_hit_idx += rw_idx_info_size[source];\n\n                for(unsigned long j=0; j < num_s_rw-rw_idx_info_size[source]; j++){ //rand walk online\n                    int des = random_walk(source,seed);\n                    freq[des] += 1;\n                }\n            }else{ // using previously generated idx is enough\n                for(unsigned long k=0; k<num_s_rw; k++){\n                    int des = rw_idx[rw_idx_info_offset[source] + k];\n                    freq[des] += 1;\n                }\n//                num_hit_idx += num_s_rw;\n            }\n        }\n    }\n    if(visual_mode==INTERACT_MODE){\n        for(int T:super2leaf[Father]){\n            double pprdeg=0;\n            if(fwdidx.first.exist(T) )\n                pprdeg+=fwdidx.first[T];\n            pprdeg+=check_rsum*freq[T]/(double)num_random_walk;\n            if (pprdeg>0){\n                spprs.push_back(S);\n                spprt.push_back(T);\n                spprv.push_back(pprdeg);\n            }\n        }\n    }\n    else{//FULL_MODE here\n        for(int T:graph.nodes){\n            double pprdeg=0;\n            if(fwdidx.first.exist(T) )\n                pprdeg+=fwdidx.first[T];\n            pprdeg+=check_rsum*freq[T]/(double)num_random_walk;\n            if (pprdeg>0){\n                spprs.push_back(S);\n                spprt.push_back(T);\n                spprv.push_back(pprdeg);\n            }\n        }\n    }\n    fill(freq.begin(),freq.end(),0);\n}\n\nvoid compute_super_ppr_with_fwdidx(const string &S, const string &Father,\n                                   unsigned long long &num_random_walk, double omega,\n                                   double check_rsum, int tid,\n                                   vector<int> &spprs,vector<int> &spprt,vector<double> &spprv,\n                                   unsigned int &seed){\n    // INFO(\"rsum is:\", check_rsum);\n    int compo,level;\n    int Sid = extract_supernode(S,compo,level);\n\n    Fwdidx &vfwdidx = virtual_fwd_idx[tid];\n    if(check_rsum == 0.0 or omega * check_rsum < 1){\n        for(int Tid:super2super[Father]){\n            double pprdeg=0;\n            string Tname = \"c\"+to_string(compo)+\"_l\"+to_string(level)+\"_\"+to_string(Tid);\n            for(int leaf:super2leaf[Tname]){\n                if(vfwdidx.first.exist(leaf) )\n                    pprdeg+= vfwdidx.first[leaf];\n            }\n            if (pprdeg>0){\n                spprs.push_back(Sid);\n                spprt.push_back(Tid);\n                spprv.push_back(pprdeg / (double)super2leaf[Tname].size());\n            }\n        }\n        return;\n    }\n\n    // todo: modify here\n    vector<int> &freq = rwfreq[tid];\n    // INFO(num_random_walk);\n\n    //rand walk online\n    if (graph.isOnline){\n        for(long i=0; i < vfwdidx.second.occur.m_num; i++){\n            int source = vfwdidx.second.occur[i];\n            double residual = vfwdidx.second[source];\n//            if (residual<threshold)\n            if (residual==0)\n                continue;\n//            nnz++;\n            unsigned long num_s_rw = ceil(residual*omega);\n//            num_total_rw += num_s_rw;\n//            num_rw_level += num_s_rw;\n            num_random_walk+=num_s_rw;\n\n\n            for(unsigned long j=0; j<num_s_rw; j++){\n                int des = random_walk(source,seed);\n                freq[des] += 1;\n            }\n        }\n    }else{\n        vfwdidx.second.occur.Sort();\n        for(long i=0; i < vfwdidx.second.occur.m_num; i++){\n            int source = vfwdidx.second.occur[i];\n            double residual = vfwdidx.second[source];\n//            if(residual<threshold)\n            if (residual==0)\n                continue;\n//            nnz++;\n            unsigned long num_s_rw = ceil(residual*omega);\n//            num_total_rw += num_s_rw;\n//            num_rw_level += num_s_rw;\n            num_random_walk += num_s_rw;\n\n            //for each source node, get rand walk destinations from previously generated idx or online rand walks\n            if(num_s_rw > rw_idx_info_size[source]){ //if we need more destinations than that in idx, rand walk online\n                for(unsigned long k=0; k<rw_idx_info_size[source]; k++){\n                    int des = rw_idx[rw_idx_info_offset[source] + k];\n                    freq[des] += 1;\n                }\n//                num_hit_idx += rw_idx_info_size[source];\n\n                for(unsigned long j=0; j < num_s_rw-rw_idx_info_size[source]; j++){ //rand walk online\n                    int des = random_walk(source,seed);\n                    freq[des] += 1;\n                }\n            }else{ // using previously generated idx is enough\n                for(unsigned long k=0; k<num_s_rw; k++){\n                    int des = rw_idx[rw_idx_info_offset[source] + k];\n                    freq[des] += 1;\n                }\n//                num_hit_idx += num_s_rw;\n            }\n        }\n    }\n\n    for(int Tid:super2super[Father]){\n        double pprdeg=0;\n        string Tname = \"c\"+to_string(compo)+\"_l\"+to_string(level)+\"_\"+to_string(Tid);\n        for(int leaf:super2leaf[Tname]){\n            if(vfwdidx.first.exist(leaf) )\n                pprdeg+= vfwdidx.first[leaf];\n            pprdeg+=check_rsum*freq[leaf]/(double)num_random_walk;\n        }\n        if (pprdeg>0){\n            spprs.push_back(Sid);\n            spprt.push_back(Tid);\n            spprv.push_back(pprdeg / (double)super2leaf[Tname].size());\n        }\n    }\n    fill(freq.begin(),freq.end(),0);\n\n}\n\n/*\n * store the residue, reserve and randwalk value for different level update\n * stack like\n * */\nvoid fora_super_pprdeg(const string &S, const string &Father,\n                       double rmax, double omega, int dsum, int tid,\n                       vector<int> &spprs,vector<int> &spprt,vector<double> &spprv,\n                       unsigned int &seed){\n    double start = omp_get_wtime();\n    double rsum=0;\n    //forward propagation, obtain reserve and residual\n    forward_local_update_virtual(S,Father,rsum, rmax,dsum,tid);\n    //reserve mem for superPPRDeg\n    Fwdidx & vfwdidx = virtual_fwd_idx[tid];\n    spprs.reserve(vfwdidx.first.occur.m_num);\n    spprt.reserve(vfwdidx.first.occur.m_num);\n    spprv.reserve(vfwdidx.first.occur.m_num);\n//    cout<<\"super fwd time:\"<<omp_get_wtime()-start<<endl;\n    if (verbose){\n        cout << \"fwd time:\"<<timeBy(start)<<endl;\n        cout <<\"rmax: \"<<rmax <<endl;\n    }\n//    graph.rmaxs += rmax;\n//    graph.rsums += rsum;\n    start = omp_get_wtime();\n    unsigned long long num_random_walk=0;\n    compute_super_ppr_with_fwdidx(S,Father,num_random_walk,omega, rsum,tid,spprs,spprt,spprv,seed);\n//    cout << \"omega * check_rsum: \"<<omega * rsum<<endl;\n//    cout<<\"super rw time:\"<<omp_get_wtime()-start<<endl;\n//    cout<<\"walk number: \"<<num_random_walk<<endl;\n    // clear virtual_fwd_idx\n    vfwdidx.first.clean();\n    vfwdidx.second.clean();\n    if (verbose){\n        cout << \"rsum: \"<<rsum<<endl;\n        cout << \"omega: \"<<omega<<endl;\n        cout << \"rsum*omega: \"<<rsum*omega<<endl;\n        cout<<\"walk time: \"<<timeBy(start)<<endl;\n//        cout << \"nnz: \"<<nnz<<endl;\n        cout<<\"walk number: \"<<num_random_walk<<endl;\n        cout<<\"--------------\"<<endl;\n    }\n//    nnz=0;\n}\n\nint static get_indice(int i,int j, int n){\n    return i*n+j;\n}\n\nvoid config_superpprdeg(int level, vector<string> &childrens, double &epsilonR, double &delta, int &tau, vector<int> &leafsize,\n                        vector<int> &dsum, double &Delta, double &maxval, double &minval, int &nrow) {\n    epsilonR= graph.epR;\n    delta= graph.delta;\n    tau= INT_MAX;\n    Delta= 0;\n    maxval= 1 - pow(graph.n, -2 * epsilonR);\n    minval= 1 - exp(-2 * epsilonR);\n    nrow= childrens.size();\n    double start = omp_get_wtime();//    double delta = pow(25,level-1)*graph.delta;\n// tau = min_{C\\in V_i}|Leaf(C)|\n// record |Leaf(C)| for each C\n// record d_{sum}(C) for each C\n    int id = 0;\n    vector<int> &ids = *leaf2id;\n    ids.resize(graph.n,-1);\n    for (int i = 0; i < childrens.size(); ++i) {\n        string &child = childrens[i];\n        int size = super2leaf[child].size();\n        leafsize[i] = size;\n        if (size<tau)\n            tau = size;\n        vector<int> &leafs = super2leaf[child];\n        for(int j=0;j<leafs.size();++j){\n            int leaf = leafs[j];\n            dsum[i] += graph.g[leaf].size();\n            ids[leaf] = id;\n            id++;\n        }\n    }\n//    fwdcache->resize(id);\n//    // todo: reserve here for openmp\n//    graph.rmaxs=0;\n//    graph.rsums=0;// Delta = \\sum_{C\\in V_i} d_{sum}(C)/|Leaf(C)|\n    for (int i = 0; i < childrens.size(); ++i) {\n        Delta += (double)dsum[i]/leafsize[i];\n    }\n    double deltap,epsilonp,rmax;\n    timeElasped += omp_get_wtime()-start;\n}\n\nvoid allpair_super_pprdeg(const string &supernode, int level,\n                          vector<string> &childrens, vector<int> &node2id){\n\n    double start,epsilonR,delta,Delta,epsilonp, maxval, minval;\n    int tau,nrow;\n    vector<int> leafsize(childrens.size());\n    vector<int> dsum(childrens.size());\n    config_superpprdeg(level, childrens, epsilonR, delta, tau, leafsize, dsum, Delta, maxval, minval, nrow);\n    int childsize = childrens.size();\n    double mint=10000,maxt=0;\n    start = omp_get_wtime();\n    double t = 0;\n#pragma omp parallel num_threads(thread_num)\n//#pragma omp single\n#pragma omp for schedule(static) nowait\n    for (int i = 0; i < childrens.size(); ++i) {\n        double rmax = 0;\n        double omega = 0;\n        double s1 = omp_get_wtime();\n        assert(omp_get_num_threads()==thread_num);\n        string &child = childrens[i];\n        vector<int> spprs, spprt;\n        vector<double> spprv;\n        // parameter settings for each ss superppr\n        // set deltap for current source supernode as the average degree of its leaf nodes\n//        double deltap = min((double) dsum[i] / leafsize[i] * delta, 1.0);\n        double deltap = (double) dsum[i] / leafsize[i] * delta;\n        // set the corresponding epsilonp for current source supernode\n        epsilonp = min(maxval, max(1 - pow(2 * deltap / exp(1), epsilonR), minval));\n        // rmax and omega settings for FORA\n        rmax = epsilonp *\n               sqrt(tau * Delta * deltap / (2.0 * graph.m) / (2 + 2 * epsilonp / 3.0) / log(1 / graph.pfail));\n//        cout << \"rmax:\"<<rmax<<\" epsilonp:\"<<epsilonp<<\" deltap:\"<<deltap<<endl;\n        rmax *= pow(2, level - 2) * graph.rmax_scale;\n//        cout << \"scaled rmax:\"<<rmax<<endl;\n        omega = (2 + 2 * epsilonp / 3.0) * log(1 / graph.pfail) / epsilonp / epsilonp / deltap / tau;\n        if (verbose) {\n            cout << \"Delta: \" << Delta << endl;\n            cout << \"tau: \" << tau << endl;\n            cout << \"deltap: \" << deltap << endl;\n            cout << \"epsilonp: \" << epsilonp << endl;\n        }\n        unsigned int seed = (i+1)*(omp_get_thread_num()+1);\n        fora_super_pprdeg(child, supernode, rmax, omega, dsum[i], omp_get_thread_num(),spprs,spprt,spprv,seed);\n        long leng = spprs.size();\n        int idx;\n        if(visual_mode==INTERACT_MODE){\n            for (int i = 0; i < leng; ++i) {\n                idx = get_indice(node2id[spprs[i]], node2id[spprt[i]], nrow);\n                PPRDeg[idx] = spprv[i];\n            }\n        }\n        else{\n            for (int i = 0; i < leng; ++i) {\n                idx = get_indice(spprs[i], spprt[i], nrow);\n                PPRDeg[idx] = spprv[i];\n            }\n        }\n        double t = omp_get_wtime()-s1;\n//        cout<<\"thread \"<<omp_get_thread_num()<<\" child \"<<i<<\" time: \"<<t<<endl;\n    }\n//    cout<<t<<\" \"<<omp_get_wtime()-start<<endl;\n//    cout <<\"ppr time:\"<<omp_get_wtime()-start<<endl;\n    timeElasped += omp_get_wtime()-start;\n}\n\n/*\n *  from level 1 to leaf node\n */\n\nvoid fora_pprdeg(int &S, const string &Father, double rmax, double omega, int tid,\n                 vector<int> &spprs,vector<int> &spprt,vector<double> &spprv,\n                 unsigned int &seed){\n    double start = omp_get_wtime();\n    double rsum=0;\n    //forward propagation, obtain reserve and residual\n    //normal forward push with loading stack\n    forward_local_update_linear(S,Father,rsum,rmax, tid);\n    Fwdidx &fwdidx = fwd_idx[tid];\n    spprs.reserve(fwdidx.first.occur.m_num);\n    spprt.reserve(fwdidx.first.occur.m_num);\n    spprv.reserve(fwdidx.first.occur.m_num);\n//    cout << \"fwd time:\"<<omp_get_wtime()-start<<endl;\n    if (verbose){\n        cout << \"fwd time:\"<<timeBy(start)<<endl;\n        cout <<\"rmax: \"<<rmax <<endl;\n    }\n//    graph.rmaxs+=rmax;\n//    graph.rsums+=rsum;\n    start = omp_get_wtime();\n    unsigned long long num_random_walk=0;\n    compute_ppr_with_fwdidx(S, Father,num_random_walk,omega, rsum, tid,spprs,spprt,spprv,seed);\n//    cout<<\"walk number: \"<<num_random_walk<<endl;\n//    cout << \"rw time:\"<<omp_get_wtime()-start<<endl;\n    // clear virtual_fwd_idx\n    fwdidx.first.clean();\n    fwdidx.second.clean();\n    if (verbose){\n        cout << \"rsum: \"<<rsum<<endl;\n        cout << \"omega: \"<<omega<<endl;\n        cout << \"rsum*omega: \"<<rsum*omega<<endl;\n        cout<<\"walk time: \"<<timeBy(start)<<endl;\n//        cout << \"nnz: \"<<nnz<<endl;\n        cout<<\"walk number: \"<<num_random_walk<<endl;\n        cout<<\"--------------\"<<endl;\n    }\n//    nnz=0;\n}\n\n\nvoid configure_pprdeg(int level, vector<int> &leaf, double &epsilonR, int &tau, double &Delta, double &maxval,\n                      double &minval, int &nrow) {\n    epsilonR= graph.epR;\n    tau= 1;\n    Delta= 0;\n    maxval= 1 - pow(graph.n, -2 * epsilonR);\n    minval= 1 - exp(-2 * epsilonR);\n    nrow= leaf.size();\n    double start = omp_get_wtime();// tau = min_{C\\in V_i}|Leaf(C)|\n// Delta = \\sum_{C\\in V_i} d_{sum}(C)/|Leaf(C)|\n    if(visual_mode==INTERACT_MODE){\n        int id=0;\n        vector<int> &ids = *leaf2id;\n        ids.resize(graph.n,-1);\n        for (int i:leaf) {\n            Delta += (double)graph.g[i].size();\n            ids[i] = id;\n            id++;\n        }\n        // reserve for openmp\n//        fwdcache->resize(id);\n    } else{\n        for (int i:graph.nodes) {\n            Delta += (double)graph.g[i].size();\n        }\n    }\n//    graph.rmaxs=0;\n//    graph.rsums=0;\n    timeElasped += omp_get_wtime()-start;\n}\n\nvoid allpair_pprdeg(const string &supernode, int level,\n                    vector<int> &leaf, vector<int> &node2id){\n    double start,epsilonR;\n    int tau,nrow;\n    double Delta,epsilonp,maxval,minval;\n    configure_pprdeg(level, leaf, epsilonR, tau, Delta, maxval, minval, nrow);\n    int childsize = leaf.size();\n    start = omp_get_wtime();\n    double t = 0;\n#pragma omp parallel num_threads(thread_num)\n#pragma omp for schedule(static) nowait\n    for (int id=0;id<leaf.size();id++) {\n        double s1 = omp_get_wtime();\n        double rmax = 0;\n        double omega = 0;\n        assert(omp_get_num_threads()==thread_num);\n        vector<int> spprs, spprt;\n        vector<double> spprv;\n        int i = leaf[id];\n        // parameter settings for each ss superppr\n        // set deltap for current source supernode as the average degree of its leaf nodes\n//        double deltap = min(graph.g[i].size() * graph.delta, 1.0);\n        double deltap = graph.g[i].size() * graph.delta;\n        // set the corresponding epsilonp for current source supernode\n        epsilonp = min(maxval, max(1 - pow(2 * deltap / exp(1), epsilonR), minval));\n        // rmax and omega settings for FORA\n        rmax = epsilonp / sqrt(2 * graph.m) *\n               sqrt(tau * Delta * deltap / (2 + 2 * epsilonp / 3.0) / log(1 / graph.pfail));\n//        cout << \"rmax:\"<<rmax<<\" epsilonp:\"<<epsilonp<<\" deltap:\"<<deltap<<endl;\n        rmax *= pow(2, level - 2) * graph.rmax_scale;\n//        cout << \"scaled rmax:\"<<rmax<<endl;\n        omega = (2 + 2 * epsilonp / 3.0) * log(1 / graph.pfail) / epsilonp / epsilonp / deltap / tau;\n        if (verbose) {\n            cout << \"Delta: \" << Delta << endl;\n            cout << \"deltap: \" << deltap << endl;\n            cout << \"epsilonp: \" << epsilonp << endl;\n            cout << \"deltap*epsilonp: \" << deltap * epsilonp << endl;\n        }\n        unsigned int seed = (id+1)*(omp_get_thread_num()+1);\n        fora_pprdeg(i, supernode, rmax, omega, omp_get_thread_num(),spprs,spprt,spprv,seed);\n\n        long leng = spprs.size();\n        int idx;\n        if(visual_mode==INTERACT_MODE){\n            for (int i = 0; i < leng; ++i) {\n                idx = get_indice(node2id[spprs[i]], node2id[spprt[i]], nrow);\n                PPRDeg[idx] = spprv[i];\n            }\n        }\n        else{\n            for (int i = 0; i < leng; ++i) {\n                idx = get_indice(spprs[i], spprt[i], nrow);\n                PPRDeg[idx] = spprv[i];\n            }\n        }\n        double t = omp_get_wtime()-s1;\n//        cout<<\"thread \"<<omp_get_thread_num()<<\" child \"<<id<<\" time: \"<<t<<endl;\n    }\n//    cout<<t<<\" \"<<omp_get_wtime()-start<<endl;\n//    cout <<\"ppr time:\"<<omp_get_wtime()-start<<endl;\n    timeElasped += omp_get_wtime()-start;\n}\n\n//void store_pprdeg(const string &supernode){\n//    string prefix = storepath+supernode;\n//    string datapath;\n//    datapath = prefix+\".src\";\n////    cout<<datapath<<endl;\n//    ofstream fout(datapath, ios::out | ios::binary);\n//    fout.write((char*)&superPPRDegS[0], superPPRDegS.size() * sizeof(int));\n//    fout.close();\n//    datapath = prefix+\".dst\";\n//    ofstream fout1(datapath, ios::out | ios::binary);\n//    fout1.write((char*)&superPPRDegT[0], superPPRDegT.size() * sizeof(int));\n//    fout1.close();\n//    datapath = prefix+\".ppr\";\n//    ofstream fout2(datapath, ios::out | ios::binary);\n//    fout2.write((char*)&superPPRDegVal[0], superPPRDegVal.size() * sizeof(double));\n//    fout2.close();\n//}\n\nvoid store_position(const string &supernode, const Coordinate2d &projections){\n    unsigned M = projections.rows();\n    string prefix = storepath+supernode;\n    string datapath;\n    datapath = prefix+\".x\";\n    ofstream fout(datapath, ios::out | ios::binary);\n    fout.write((char*)(projections.data()+0), M * sizeof(double));\n    fout.close();\n    datapath = prefix+\".y\";\n    ofstream fout1(datapath, ios::out | ios::binary);\n    fout1.write((char*)(projections.data()+M), M * sizeof(double));\n    fout1.close();\n}\nvoid store_radius(const string &supernode, const vector<double> &r){\n    unsigned M = r.size();\n    string prefix = storepath+supernode;\n    string datapath;\n    datapath = prefix+\".r\";\n    ofstream fout(datapath, ios::out | ios::binary);\n    fout.write((char*)&r[0], M * sizeof(double));\n    fout.close();\n}\n\n\ndouble calculateSigma( const vector<double>& Weights, const vector<double>& Distances, const Coordinate2d & InitialZ, vector<double>& dists ) {\n    unsigned M = InitialZ.rows();\n    double sigma=0;\n    for(unsigned i=1; i<M; ++i) {\n        for(unsigned j=0; j<i; ++j) {\n            double dlow=0;\n            for(unsigned k=0; k<InitialZ.cols(); ++k) {\n                double tmp=InitialZ(i,k) - InitialZ(j,k);\n                dlow+=tmp*tmp;\n            }\n            dists[get_indice(i,j,M)]=dists[get_indice(j,i,M)]=sqrt(dlow);\n            double tmp3 = Distances[get_indice(i,j,M)] - dists[get_indice(i,j,M)];\n            sigma += Weights[get_indice(i,j,M)]*tmp3*tmp3;\n        }\n    }\n    return sigma;\n}\n\n\nvoid Smacof( const vector<double>& Weights, const vector<double>& Distances, const double& tol, const unsigned& maxloops, Coordinate2d& InitialZ ) {\n    unsigned M = InitialZ.rows();\n    if(M>100){\n        Eigen::initParallel();\n        Eigen::setNbThreads(thread_num);\n    }\n\n    // Calculate V\n    MatrixXd V(M,M);\n    double totalWeight=0.;\n    for(unsigned i=0; i<M; ++i) {\n        for(unsigned j=0; j<M; ++j) {\n            if(i==j) continue;\n            V(i,j)=-Weights[get_indice(i,j,M)];\n            if( j<i ) totalWeight+=Weights[get_indice(i,j,M)];\n        }\n        for(unsigned j=0; j<M; ++j) {\n            if(i==j)continue;\n            V(i,i)-=V(i,j);\n        }\n    }\n\n    // And pseudo invert V\n    MatrixXd mypseudo = pseudoInverse(V,1e-15);\n    vector<double> dists(M*M,0);\n    double myfirstsig = calculateSigma( Weights, Distances, InitialZ, dists ) / totalWeight;\n\n    // initial sigma is made up of the original distances minus the distances between the projections all squared.\n    MatrixXd BZ( M, M );\n    Coordinate2d newZ;\n    for(unsigned n=0; n<maxloops; ++n) {\n//    if(n==maxloops-1) plumed_merror(\"ran out of steps in SMACOF algorithm\");\n\n        // Recompute BZ matrix\n        for(unsigned i=0; i<M; ++i) {\n            for(unsigned j=0; j<M; ++j) {\n                if(i==j) continue;  //skips over the diagonal elements\n\n                if( dists[get_indice(i,j,M)]>0 ) BZ(i,j) = -Weights[get_indice(i,j,M)]*Distances[get_indice(i,j,M)] / dists[get_indice(i,j,M)];\n                else BZ(i,j)=0.;\n            }\n            //the diagonal elements are -off diagonal elements BZ(i,i)-=BZ(i,j)   (Equation 8.25)\n            BZ(i,i)=0; //create the space memory for the diagonal elements which are scalars\n            for(unsigned j=0; j<M; ++j) {\n                if(i==j) continue;\n                BZ(i,i)-=BZ(i,j);\n            }\n        }\n        newZ = mypseudo*(BZ*InitialZ);\n        //Compute new sigma\n        double newsig = calculateSigma( Weights, Distances, newZ, dists ) / totalWeight;\n        //Computing whether the algorithm has converged (has the mass of the potato changed\n        //when we put it back in the oven!)\n        if( fabs( newsig - myfirstsig )<tol ) break;\n        myfirstsig=newsig;\n        InitialZ = newZ;\n    }\n}\nvoid add_radius(vector<double> &D, vector<int>& nodeweight, vector<double>& r, double avgsize, double avgdist, double scaler=0.03){\n    double scale = scaler*avgdist/sqrt(avgsize);\n    double M = nodeweight.size();\n    for (int i = 0; i < M; ++i) {\n        r[i] = scale*sqrt(nodeweight[i]);\n    }\n    // update Distance by adding radius\n    for (int i = 0; i < M; ++i) {\n        for (int j = 0; j < M; ++j) {\n            D[get_indice(i,j,M)] += r[i]+r[j];\n        }\n    }\n\n}\n\n\n\nvoid relativeMDS(const double& tol, const unsigned& maxloops, Coordinate2d& projections, vector<double> &r, vector<int>& nodeweight){\n    int nrow = projections.rows();\n    vector<double> weights(nrow*nrow);\n    vector<double> pprdist(nrow*nrow);\n\n    double val;\n    double maxval = 2*log2(graph.n);\n    double minval = 2;\n    double avgsize = 0, avgdist = 0;\n    for (int i = 0; i < nrow; ++i) {\n        avgsize += nodeweight[i];\n        for (int j = 0; j < nrow; ++j) {\n            val = PPRDeg[get_indice(i,j,nrow)]+PPRDeg[get_indice(j,i,nrow)];\n            if (val==0) val = maxval;\n            else val = 1 - log2(val);\n            val = min(max(minval, val), maxval);\n            avgdist += val;\n            pprdist[get_indice(i,j,nrow)] = val;\n            weights[get_indice(i,j,nrow)] = 1/val/val;\n        }\n    }\n    avgsize /= nrow;\n    avgdist /= (nrow*nrow);\n    add_radius(pprdist, nodeweight, r, avgsize, avgdist);\n    Smacof( weights, pprdist, tol, maxloops, projections );\n\n}\nvoid zoom_in(const string &supernode, int level, vector<string> &children){\n    double start = omp_get_wtime();\n//    num_rw_level=0;\n    int nrow;\n    vector<int> node2id(graph.n,-1);\n    // get the top of fwd cache stack\n//    fwdcache = &fwd_stack[fwd_stack_top];\n    leaf2id = &leaf2id_stack[fwd_stack_top];\n    vector<int> nodeweight;\n    if(level==1){\n        vector<int> &leaf = super2leaf[supernode];\n        nrow = leaf.size();\n        PPRDeg.resize(nrow*nrow,0);\n        nodeweight.resize(nrow,1);\n        for (int i = 0; i < nrow; ++i) {\n            node2id[leaf[i]] = i;\n        }\n        timeElasped += omp_get_wtime()-start;\n        allpair_pprdeg(supernode,level,leaf,node2id);\n        if(verbose){\n            for(const auto& each:leaf)\n                cout<<each<<\" \";\n            cout<<endl;\n        }\n    }\n    else{\n        vector<int> &child = super2super[supernode];\n        nrow = child.size();\n        PPRDeg.resize(nrow*nrow,0);\n        nodeweight.resize(nrow,1);\n        for (int i = 0; i < nrow; ++i) {\n            node2id[child[i]] = i;\n            nodeweight[i] = super2leaf[children[i]].size();\n        }\n        timeElasped += omp_get_wtime()-start;\n        allpair_super_pprdeg(supernode,level,children,node2id);\n//        cout<<\"number of children: \"<<children.size()<<endl;\n        if(verbose){\n            for(const auto& each:children)\n                cout<<each<<\" \";\n            cout<<endl;\n        }\n    }\n//    cerr << \"ppr time: \"<<timeBy(start)<<endl;\n    double start2 = omp_get_wtime();\n    double tol=1e-9;\n    unsigned maxloops=3000;\n    Coordinate2d projections = Coordinate2d::Random(nrow,2);\n    vector<double> r(nrow);\n    relativeMDS(tol,maxloops,projections,r,nodeweight);\n    timeElasped += omp_get_wtime()-start2;\n//    cerr << \"mds time: \"<<omp_get_wtime()-start2<<endl;\n//    cerr << \"num of rw: \"<<num_rw_level<<endl;\n    store_position(supernode,projections);\n    // store supernode radius\n    store_radius(supernode,r);\n    // increase top for stack\n    fwd_stack_top++;\n    PPRDeg.clear();\n}\n\nvoid interactive_visualize(vector<string> &path){\n    // print the components in the root view\n//    for(const auto& each:root)\n//        cout<<each<<\" \";\n//    cout<<endl;\n    vector<string> childrens;\n    int level;\n//    vector<string> path = {\"c0_l4_0\",\"c0_l3_19\",\"c0_l2_0\",\"c0_l1_1\"};\n//    vector<string> path = {\"c0_l2_0\",\"c0_l1_1\"};\n//    vector<string> path = {\"c0_l3_5\",\"c0_l2_254\"};\n//    vector<string> path = {\"c0_l3_5\",\"c0_l2_88\"};\n//    path = {\"c0_l4_0\",\"c0_l3_19\",\"c0_l2_0\",\"c0_l1_7\"};\n//    vector<string> path = {\"c0_l4_0\",\"c0_l3_19\",\"\n//    c0_l2_0\",\"c0_l1_1\"};\n//    vector<string> path = {\"c0_l4_0\",\"c0_l3_19\"};\n//    vector<string> path = {\"c0_l3_19\"};\n//    path = {\"c0_l1_7\"};\n    for(const string& supernode:path){\n//        string supernode;\n//        zoom_in(\"c0_l3_0\");\n//        cout<<\"select the above supernode to zoom in... (type -1 to exit)\"<<endl;\n//        cin >> supernode;\n        parse_children(supernode, level, childrens);\n        cerr<<\"zoom into supernode \"<<supernode<<\"...\"<<endl;\n        zoom_in(supernode,level, childrens);\n        if (level==1){\n//            cerr<<\"reach the leaf level: exiting...\"<<endl;\n            return;\n        }\n    }\n}\n\n\n#endif //INTERACT_FORA_ALGO_H\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algo.h b/algo.h
--- a/algo.h	(revision f439698caf8deac89815610cdf58f7b3b409d2c3)
+++ b/algo.h	(date 1610028500727)
@@ -235,8 +235,8 @@
     double epsilon =1-exp(-2*graph.epR);
     double Delta = 25*graph.dbar; // Delta = k*dbar k=25
     // todo: currently, use dbar*delta as deltap and tau = 1 for randwalk index construction
-//    double deltap = graph.dbar*graph.delta;
-    double deltap = graph.dbar/graph.n;
+    double deltap = graph.dbar*graph.delta;
+//    double deltap = graph.dbar/graph.n;
     double rmax = epsilon*sqrt(deltap*Delta/(2+2*epsilon/3)/2/(double)graph.m/log(1/graph.pfail));
 //    rmax *= graph.rmax_scale;
     double omega = (2+2*epsilon/3)*log(1/graph.pfail)/deltap/epsilon/epsilon;
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"CMakeRunConfigurationManager\" shouldGenerate=\"true\" shouldDeleteObsolete=\"true\">\n    <generated>\n      <config projectName=\"interact_fora\" targetName=\"interact_fora\" />\n    </generated>\n  </component>\n  <component name=\"CMakeSettings\" AUTO_RELOAD=\"true\">\n    <configurations>\n      <configuration PROFILE_NAME=\"Debug\" CONFIG_NAME=\"Debug\" ENABLED=\"true\" />\n      <configuration PROFILE_NAME=\"Release\" CONFIG_NAME=\"Release\" ENABLED=\"true\" />\n    </configurations>\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"3a22b49b-0730-47d6-9f07-4b6c1a574645\" name=\"Default Changelist\" comment=\"\">\n      <change beforePath=\"$PROJECT_DIR$/../.gitignore\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/../.gitignore\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/algo.h\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/algo.h\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/graph.h\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/graph.h\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/multilevel-FORA.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/multilevel-FORA.py\" afterDir=\"false\" />\n    </list>\n    <list id=\"5822a496-c6d6-4bc9-9c9f-36da012cd05a\" name=\"Revert &quot;use rand_r for thread safety&quot;\" comment=\"Revert &quot;use rand_r for thread safety&quot;&#10;&#10;This reverts commit e776f7fa\" />\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"ClangdSettings\">\n    <option name=\"formatViaClangd\" value=\"false\" />\n  </component>\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"CMakeBuildProfile:Release\" />\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$/..\" value=\"master\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/..\" />\n    <option name=\"RESET_MODE\" value=\"MIXED\" />\n  </component>\n  <component name=\"HighlightingSettingsPerFile\">\n    <setting file=\"file://$PROJECT_DIR$/lib.h\" root0=\"SKIP_HIGHLIGHTING\" />\n  </component>\n  <component name=\"ProjectId\" id=\"1go9SThgpLZsjmBAwmjPwQhC7mn\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"TERMINAL_CUSTOM_COMMANDS_GOT_IT\" value=\"true\" />\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\n    <property name=\"cf.first.check.clang-format\" value=\"false\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\n    <property name=\"node.js.detected.package.eslint\" value=\"true\" />\n    <property name=\"node.js.detected.package.tslint\" value=\"true\" />\n    <property name=\"node.js.path.for.package.eslint\" value=\"project\" />\n    <property name=\"node.js.path.for.package.tslint\" value=\"project\" />\n    <property name=\"node.js.selected.package.eslint\" value=\"(autodetect)\" />\n    <property name=\"node.js.selected.package.tslint\" value=\"(autodetect)\" />\n    <property name=\"nodejs_interpreter_path.stuck_in_default_project\" value=\"undefined stuck path\" />\n    <property name=\"nodejs_npm_path_reset_for_default_project\" value=\"true\" />\n    <property name=\"nodejs_package_manager_path\" value=\"npm\" />\n    <property name=\"settings.editor.selected.configurable\" value=\"CMakeSettings\" />\n  </component>\n  <component name=\"RecentsManager\">\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$\" />\n      <recent name=\"$PROJECT_DIR$/plumed-smacof\" />\n      <recent name=\"$PROJECT_DIR$/plumed-smacof/tools\" />\n      <recent name=\"$PROJECT_DIR$/plumed-smacof/dimred\" />\n      <recent name=\"$PROJECT_DIR$/\" />\n    </key>\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$\" />\n      <recent name=\"$PROJECT_DIR$/plumed-smacof\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"CMake Application.index_construct\">\n    <configuration name=\"index_construct\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" PROGRAM_PARAMS=\"-f 21 -build 0 -ol 0 -verbose 0 -nthread 64 -sample 1\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" WORKING_DIR=\"file://$PROJECT_DIR$/\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"interact_fora\" TARGET_NAME=\"interact_fora\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"interact_fora\" RUN_TARGET_NAME=\"interact_fora\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"interact_fora\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" PROGRAM_PARAMS=\"-f 21 -build 0 -ol 0 -verbose 1\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" WORKING_DIR=\"file://$PROJECT_DIR$/\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"interact_fora\" TARGET_NAME=\"interact_fora\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"interact_fora\" RUN_TARGET_NAME=\"interact_fora\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"GradleAppRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.cpp.gradle.execution.GradleNativeBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <list>\n      <item itemvalue=\"CMake Application.index_construct\" />\n      <item itemvalue=\"CMake Application.interact_fora\" />\n    </list>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"SvnConfiguration\">\n    <configuration />\n  </component>\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"3a22b49b-0730-47d6-9f07-4b6c1a574645\" name=\"Default Changelist\" comment=\"\" />\n      <created>1598770078161</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1598770078161</updated>\n      <workItem from=\"1598770082424\" duration=\"14000\" />\n      <workItem from=\"1598770103081\" duration=\"17817000\" />\n      <workItem from=\"1598852892046\" duration=\"4258000\" />\n      <workItem from=\"1598857677445\" duration=\"11046000\" />\n      <workItem from=\"1598924103928\" duration=\"17218000\" />\n      <workItem from=\"1599018406394\" duration=\"1592000\" />\n      <workItem from=\"1599048736868\" duration=\"2574000\" />\n      <workItem from=\"1601000878593\" duration=\"50499000\" />\n      <workItem from=\"1601176175493\" duration=\"122000\" />\n      <workItem from=\"1601178791304\" duration=\"7195000\" />\n      <workItem from=\"1601955608230\" duration=\"420000\" />\n      <workItem from=\"1602252783006\" duration=\"488000\" />\n      <workItem from=\"1603539722716\" duration=\"870000\" />\n      <workItem from=\"1603858739972\" duration=\"5161000\" />\n      <workItem from=\"1603871294515\" duration=\"1580000\" />\n      <workItem from=\"1605580748540\" duration=\"1503000\" />\n      <workItem from=\"1605601059582\" duration=\"853000\" />\n      <workItem from=\"1605602006137\" duration=\"174000\" />\n      <workItem from=\"1605602197810\" duration=\"10037000\" />\n      <workItem from=\"1606096872953\" duration=\"100273000\" />\n      <workItem from=\"1606616008430\" duration=\"7518000\" />\n      <workItem from=\"1606705515251\" duration=\"37209000\" />\n      <workItem from=\"1606974237005\" duration=\"63000\" />\n      <workItem from=\"1607433705436\" duration=\"1661000\" />\n      <workItem from=\"1607497613787\" duration=\"28795000\" />\n      <workItem from=\"1607956442822\" duration=\"1787000\" />\n      <workItem from=\"1608111640669\" duration=\"7397000\" />\n      <workItem from=\"1608287462915\" duration=\"2625000\" />\n      <workItem from=\"1608712805593\" duration=\"6508000\" />\n      <workItem from=\"1608879492818\" duration=\"8959000\" />\n      <workItem from=\"1609127480537\" duration=\"7685000\" />\n      <workItem from=\"1609171010680\" duration=\"3001000\" />\n      <workItem from=\"1609233071536\" duration=\"35475000\" />\n      <workItem from=\"1609716902136\" duration=\"15769000\" />\n      <workItem from=\"1609806605743\" duration=\"23884000\" />\n    </task>\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"UnknownFeatures\">\n    <option featureType=\"com.intellij.fileTypeFactory\" implementationName=\"*.log\" />\n  </component>\n  <component name=\"Vcs.Log.History.Properties\">\n    <option name=\"COLUMN_ID_ORDER\">\n      <list>\n        <option value=\"Default.Root\" />\n        <option value=\"Default.Author\" />\n        <option value=\"Default.Date\" />\n        <option value=\"Default.Subject\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\n  </component>\n  <component name=\"XDebuggerManager\">\n    <watches-manager>\n      <configuration name=\"CMakeRunConfiguration\">\n        <watch expression=\"rw_idx_info_offset\" language=\"ObjectiveC\" />\n        <watch expression=\"rw_idx_info_size\" language=\"ObjectiveC\" />\n        <watch expression=\"num_hit_idx\" language=\"ObjectiveC\" />\n        <watch expression=\"num_total_rw\" language=\"ObjectiveC\" />\n        <watch expression=\"ppr_idx\" language=\"ObjectiveC\" />\n        <watch expression=\"superPPRDeg\" language=\"ObjectiveC\" />\n        <watch expression=\"reserve_stack\" language=\"ObjectiveC\" />\n        <watch expression=\"nnz\" language=\"ObjectiveC\" />\n        <watch expression=\"leaf2id\" language=\"ObjectiveC\" />\n        <watch expression=\"virtual_fwd_idx\" language=\"ObjectiveC\" />\n      </configuration>\n    </watches-manager>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision f439698caf8deac89815610cdf58f7b3b409d2c3)
+++ b/.idea/workspace.xml	(date 1610093243659)
@@ -15,9 +15,9 @@
     <list default="true" id="3a22b49b-0730-47d6-9f07-4b6c1a574645" name="Default Changelist" comment="">
       <change beforePath="$PROJECT_DIR$/../.gitignore" beforeDir="false" afterPath="$PROJECT_DIR$/../.gitignore" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/CMakeLists.txt" beforeDir="false" afterPath="$PROJECT_DIR$/CMakeLists.txt" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/algo.h" beforeDir="false" afterPath="$PROJECT_DIR$/algo.h" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/graph.h" beforeDir="false" afterPath="$PROJECT_DIR$/graph.h" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/multilevel-FORA.py" beforeDir="false" afterPath="$PROJECT_DIR$/multilevel-FORA.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../load-superppr-viz.py" beforeDir="false" afterPath="$PROJECT_DIR$/../load-superppr-viz.py" afterDir="false" />
     </list>
     <list id="5822a496-c6d6-4bc9-9c9f-36da012cd05a" name="Revert &quot;use rand_r for thread safety&quot;" comment="Revert &quot;use rand_r for thread safety&quot;&#10;&#10;This reverts commit e776f7fa" />
     <option name="SHOW_DIALOG" value="false" />
@@ -77,7 +77,7 @@
     </key>
   </component>
   <component name="RunManager" selected="CMake Application.index_construct">
-    <configuration name="index_construct" type="CMakeRunConfiguration" factoryName="Application" PROGRAM_PARAMS="-f 21 -build 0 -ol 0 -verbose 0 -nthread 64 -sample 1" REDIRECT_INPUT="false" ELEVATE="false" WORKING_DIR="file://$PROJECT_DIR$/" PASS_PARENT_ENVS_2="true" PROJECT_NAME="interact_fora" TARGET_NAME="interact_fora" CONFIG_NAME="Debug" RUN_TARGET_PROJECT_NAME="interact_fora" RUN_TARGET_NAME="interact_fora">
+    <configuration name="index_construct" type="CMakeRunConfiguration" factoryName="Application" PROGRAM_PARAMS="-f 21 -build 0 -ol 0 -verbose 0 -nthread 64 -sample 1 -ds 2500" REDIRECT_INPUT="false" ELEVATE="false" WORKING_DIR="file://$PROJECT_DIR$/" PASS_PARENT_ENVS_2="true" PROJECT_NAME="interact_fora" TARGET_NAME="interact_fora" CONFIG_NAME="Debug" RUN_TARGET_PROJECT_NAME="interact_fora" RUN_TARGET_NAME="interact_fora">
       <method v="2">
         <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
       </method>
@@ -142,7 +142,8 @@
       <workItem from="1609171010680" duration="3001000" />
       <workItem from="1609233071536" duration="35475000" />
       <workItem from="1609716902136" duration="15769000" />
-      <workItem from="1609806605743" duration="23884000" />
+      <workItem from="1609806605743" duration="35793000" />
+      <workItem from="1610076563982" duration="1375000" />
     </task>
     <servers />
   </component>
Index: ../load-superppr-viz.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\nimport networkx as nx\nimport sys\nimport time\nimport matplotlib\nimport bisect\nimport itertools\nmatplotlib.use('Agg')\nfrom evaluate import eva,cluster_extraction,normalize\nfrom pprviz import *\nimport re\nfrom config import filelist\nfrom scipy import sparse\nfrom numpy import fromfile\n\n\n# global supernode_list, mapping_data, A, n\nA=None\nGfull = None\nD = None\nsupernode_list=dict()\nmapping_data=dict()\nPPRDeg = None\nXmds = None\nr = None\nsuper2id = dict()\nid2super = []\ncomponent = 0\nlevel = 0\n\ndef load_ppr(path, size):\n    global PPRDeg\n    with open(path+\".src\", \"rb\") as fin:\n        row = np.fromfile(fin, dtype=np.int32)\n    with open(path+\".dst\", \"rb\") as fin:\n        col = np.fromfile(fin, dtype=np.int32)\n    with open(path+\".ppr\", \"rb\") as fin:\n        data = np.fromfile(fin, dtype=np.double)\n    assert (len(row)==len(col))\n    assert (len(row)==len(data))\n    # print (len(row),len(col))\n    row1 = [super2id[i] for i in row]\n    col1 = [super2id[i] for i in col]\n    PPRDeg = sparse.csr_matrix((data, (row1, col1)), shape=(size, size))\n\ndef load_position(path):\n    global Xmds, r\n    with open(path+\".x\", \"rb\") as fin:\n        x = np.fromfile(fin, dtype=np.double)\n    with open(path+\".y\", \"rb\") as fin:\n        y = np.fromfile(fin, dtype=np.double)\n    with open(path+\".r\", \"rb\") as fin:\n        r = np.fromfile(fin, dtype=np.double)\n    # print (len(row),len(col))\n    Xmds = np.vstack([x,y])\n    Xmds = Xmds.T\n\ndef load_community(hiefname, mapfname):\n    global supernode_list, mapping_data\n    with open(hiefname, \"r\") as fin:\n        while True:\n            l = fin.readline()\n            if len(l) == 0:\n                break\n            name = l.rstrip(\"\\r\\n\")\n            l = fin.readline()\n            size = int(l.rstrip(\"\\r\\n\"))\n            child = [int(fin.readline().rstrip(\"\\r\\n\")) for i in range(size)]\n            supernode_list[name] = child\n\n    with open(mapfname, \"r\") as fin:\n        while True:\n            l = fin.readline()\n            if len(l) == 0:\n                break\n            name = l.rstrip(\"\\r\\n\")\n            l = fin.readline()\n            size = int(l.rstrip(\"\\r\\n\"))\n            child = [int(fin.readline().rstrip(\"\\r\\n\")) for i in range(size)]\n            mapping_data[name] = child\n\n\ndef split_supernode(name):\n    global component, level\n    lst = name.split(\"_\")\n    component = int(lst[0][1:])\n    level = int(lst[1][1:])\n    sid = int(lst[2])\n    return sid\n\ndef get_children(node):\n    global super2id,id2super\n    split_supernode(node)\n    if level == 1:\n        childsize = len(mapping_data[node])\n        id2super = mapping_data[node]\n    else:\n        childsize = len(supernode_list[node])\n        id2super = supernode_list[node]\n    super2id = {id2super[i]: i for i in range(childsize)}\n\n    return childsize\n\ndef get_subgraph(cluster):\n    s = len(cluster)\n    cm1 = np.zeros((s, n))\n    nodeweight = [1] * s\n\n    for i in range(s):\n        supernode = cluster[i]\n        if supernode in mapping_data:\n            cidx = mapping_data[supernode]\n            nodeweight[i] = len(cidx)\n        else:\n            cidx = [supernode]\n            nodeweight[i] = 1\n        cm1[i, :] = np.sum(A[cidx, :], axis=0)\n\n    As = np.zeros((s, s))\n    for i in range(s):\n        supernode = cluster[i]\n        if supernode in mapping_data:\n            cidx = mapping_data[supernode]\n        else:\n            cidx = [supernode]\n        As[:, i] = np.sum(cm1[:, cidx], axis=1)\n\n    subG = nx.from_scipy_sparse_matrix(sparse.csr_matrix(As))\n\n    return subG, nodeweight\n\n\ndef viz(target,ds):\n    start = time.time()\n    if level==1:\n        cluster = id2super\n    else:\n        cluster = [\"c\"+str(component)+\"_l\"+str(level-1)+\"_\"+str(i) for i in id2super]\n\n    G, nodeweight = get_subgraph(cluster=cluster)\n    edges = G.edges()\n    t = time.time() - start\n    print (\"subgraph time:{}s n:{} m:{}\".format(t,G.number_of_nodes(),G.number_of_edges()))\n    if len(cluster)<3:\n        t = time.time() - start\n        simpe_plot(G=G, nodeweight=nodeweight, label=cluster, name=\"./output_refine/{}-{}-interact-fora-{}\".format(filelist[dataid], target,ds))\n        print (\"zoom-in time:{}s\".format(t))\n        return\n\n    start = time.time()\n    # todo: load radius and position\n    t = time.time() - start\n    print (\"zoom-in time:{}s\".format(t))\n\n    plot(pos=Xmds, edges=edges, radius = r,\n         name=\"./output_refine/{}-{}-interact-fora-{}\".format(filelist[dataid], target, ds))\n\n\n\nif __name__ == '__main__':\n    # global supernode_list, mapping_data, A, n\n    print (filelist)\n    # dataid = raw_input('data id :')\n    dataid = 21\n    # dataid = int(dataid.encode(\"utf-8\"))\n    dataname = filelist[dataid]\n    hiefname = 'louvain/hierachy-output/%s.dat'%dataname\n    mapfname = 'louvain/mapping-output/%s.dat'%dataname\n\n    print(\"loading clusters...\")\n    load_community(hiefname, mapfname)\n    print(\"loading edges...\")\n    # path = \"/home/zhangsq/gviz-ppr/dataset/\" + dataname +\".txt\"\n    fpath = \"dataset/\" + dataname + \".txt\"\n    Gfull = nx.read_edgelist(fpath, nodetype=int)\n    A = nx.adjacency_matrix(Gfull)\n    n = Gfull.number_of_nodes()\n\n    # dss=[100,500,1000,5000,10000,50000,100000]\n    dss=[2500]\n    for ds in dss:\n        storename = \"{}_idx/{}ds{}\".format(dataname, dataname, ds)\n        # zoompath = [\"c0_l4_0\",\"c0_l3_5\",\"c0_l3_19\",\"c0_l2_254\",\"c0_l2_88\",\"c0_l2_0\",\"c0_l1_1\",\"c0_l1_7\"]\n        # zoompath = [\"c0_l4_0\",\"c0_l3_19\",\"c0_l2_0\",\"c0_l1_1\"]\n        zoompath = [\"c0_l4_0\",\"c0_l3_19\",\"c0_l2_0\",\"c0_l1_7\"]\n        print (zoompath)\n        for each in zoompath:\n            childsize = get_children(each)\n            pprpath = storename+each\n            # todo: map childnode from 0 to size-1\n            # load_ppr(pprpath, childsize)\n            load_position(pprpath)\n            viz(each,ds)\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../load-superppr-viz.py b/../load-superppr-viz.py
--- a/../load-superppr-viz.py	(revision f439698caf8deac89815610cdf58f7b3b409d2c3)
+++ b/../load-superppr-viz.py	(date 1610027410247)
@@ -177,7 +177,7 @@
     n = Gfull.number_of_nodes()
 
     # dss=[100,500,1000,5000,10000,50000,100000]
-    dss=[2500]
+    dss=[100,200,300,400,500,1000,2000,2500]
     for ds in dss:
         storename = "{}_idx/{}ds{}".format(dataname, dataname, ds)
         # zoompath = ["c0_l4_0","c0_l3_5","c0_l3_19","c0_l2_254","c0_l2_88","c0_l2_0","c0_l1_1","c0_l1_7"]
Index: CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>cmake_minimum_required(VERSION 3.10)\nproject(interact_fora)\n\nset(CMAKE_CXX_STANDARD 11)\n#SET(CMAKE_CXX_FLAGS \"-std=c++11 -O3 -DNDEBUG -w -pthread -lboost_serialization -lboost_filesystem -lboost_system\")\n\nset(CMAKE_CXX_FLAGS_DEBUG \"-g\")\n#set(CMAKE_CXX_FLAGS_DEBUG \"-O0\")\nset(CMAKE_CXX_FLAGS_RELEASE \"-O3\")\n\nfind_package(Boost REQUIRED system serialization)\nINCLUDE_DIRECTORIES( ${Boost_INCLUDE_DIR} )\n\n# download + cmake + make install + include directories: http://eigen.tuxfamily.org/index.php?title=Main_Page\nfind_package(Eigen3)\nINCLUDE_DIRECTORIES(${EIGEN3_INCLUDE_DIR})\n\n#set(CMAKE_BINARY_DIR ${CMAKE_SOURCE_DIR})\n#set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR})\n#set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR})\n\ninclude_directories(\"${PROJECT_SOURCE_DIR}\")\nfile(GLOB SOURCES \"*.cpp\")\nadd_executable(interact_fora ${SOURCES})\n\nfind_package(OpenMP REQUIRED)\nif(NOT TARGET OpenMP::OpenMP_CXX)\n    add_library(OpenMP_TARGET INTERFACE)\n    add_library(OpenMP::OpenMP_CXX ALIAS OpenMP_TARGET)\n    target_compile_options(OpenMP_TARGET INTERFACE ${OpenMP_CXX_FLAGS})\n    find_package(Threads REQUIRED)\n    target_link_libraries(OpenMP_TARGET INTERFACE Threads::Threads)\n    target_link_libraries(OpenMP_TARGET INTERFACE ${OpenMP_CXX_FLAGS})\nendif()\ntarget_link_libraries(${PROJECT_NAME} ${Boost_LIBRARIES} OpenMP::OpenMP_CXX)\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	(revision f439698caf8deac89815610cdf58f7b3b409d2c3)
+++ b/CMakeLists.txt	(date 1610012605451)
@@ -4,8 +4,8 @@
 set(CMAKE_CXX_STANDARD 11)
 #SET(CMAKE_CXX_FLAGS "-std=c++11 -O3 -DNDEBUG -w -pthread -lboost_serialization -lboost_filesystem -lboost_system")
 
-set(CMAKE_CXX_FLAGS_DEBUG "-g")
-#set(CMAKE_CXX_FLAGS_DEBUG "-O0")
+#set(CMAKE_CXX_FLAGS_DEBUG "-g")
+set(CMAKE_CXX_FLAGS_DEBUG "-O0")
 set(CMAKE_CXX_FLAGS_RELEASE "-O3")
 
 find_package(Boost REQUIRED system serialization)
